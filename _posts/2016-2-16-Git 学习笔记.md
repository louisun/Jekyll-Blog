---
layout: post
title: Git 学习笔记
toc: true
tags: ['Git']
cover: 'http://7xj74s.com1.z0.glb.clouddn.com/2018-01-25-12-33-41_r37.png'
---
<!-- 

time: 2016-2-16

cover: http://7xj74s.com1.z0.glb.clouddn.com/2018-01-25-12-33-41_r37.png

 -->





<!-- more -->



## 基本概念

![Git区域概念](http://7xj74s.com1.z0.glb.clouddn.com/Markdown_git-2-16-0.jpg)



`workspace` 称为**工作区**, 就是当前看到的目录



`repository`称为**版本库/仓库**, 就是`commit`的目的区域, 工作区中隐藏的目录`.git`就是版本库, ` repository` 存了很多东西, 最重要的是`stage`(称为**暂存区**, 即图中的 `index`), 以及自动创建的第一个分支`master`, 和指向`master`的指针`HEAD`



![](http://7xj74s.com1.z0.glb.clouddn.com/Markdown_git-2-16-1.jpg)



<!-- more -->





`remote`是**远程仓库**







`git add`把文件添加进去，实际上就是把文件修改添加到暂存区







`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支`master`的 `repository`











`git status`可以让我们时刻掌握**仓库**当前的状态







`git log`可以显示历史的提交记录







`git diff HEAD -- file`命令可以查看`workspace`和`repository`里面最新版本的区别, HEAD 可以改为其它版本





## 撤销修改

在`add`之前想要撤销文件的更改, `git checkout -- file`可以丢弃`workspacce`的修改



`--`很重要，没有`--`，就变成了“**切换到另一个分支**”的命令



而如果已经`add`到`stage暂存区`了, 还未`commit`到`repository`, 可以使用`git reset HEAD file`对该文件进行版本回退, 或者`git reset --hard HEAD`直接回退所有文件



而如果已经`commit`到`repository`了, 还没有`push`到远程库的话, 直接版本回退就好了



如果已经提交到`远程库`了, 那就 T_T ...





`git reset --hard commit_id` 可以切换到指定**提交(commit)**的版本





 Git 中`HEAD`是指当前版本, 所以 `git reset --hard HEAD^ `是切换到**上一版本**, `HDAD^^`是**上上版本**, `HEAD~100`是100个版本之前, 切换版本的时候, 顺便把工作区文件更新了. 让`HEAD`定位在那, 当前版本就定位在哪



 ![](http://7xj74s.com1.z0.glb.clouddn.com/Markdown_git-2-16-2.jpg)



---



在 Git 中总有后悔药吃, 想回退到某一版本, 不知道`commit id`, 可以用`git reflog`寻找, 此命令记录每一次的命令



```bash

$ git reflog

ea34578 HEAD@{0}: reset: moving to HEAD^

3628164 HEAD@{1}: commit: append GPL

ea34578 HEAD@{2}: commit: add distributed

cb926e7 HEAD@{3}: commit (initial): wrote a readme file

```









## 删除文件



如果在`workspace`删除了文件, 与`repository`不一致了, 要用 `git rm`删掉, 并且 `commit`



如果是误删, 可以使用`git checkout -- deleted_file` 恢复, 还记得该命令能在`add`之前恢复工作区的作用吗





## 远程仓库



[SSH协议](http://www.wikiwand.com/zh/Secure_Shell)





创建`SSH Key`在`.ssh`目录下生成`id_rsa`(私钥)和`id_rsa.pub`(公钥)两个文件  



```bash

$ ssh-keygen -t rsa -C "youremail@example.com"

```





**先有本地库，后有远程库的时候，如何关联远程库**



```bash



添加远程仓库 (可以用来 push / fetch )



$ git remote add origin git@github.com:yourName/yourRepository.git

```



远程库的名字就是`origin`，这是Git`默认的叫法`，也可以改成别的，但是`origin`这个名字一看就知道是远程库



---



推送



```bash

$ git push -u origin master

```





第一次 `push` 时 `-u` 参数表示 关联 本地 `master` 和 远程 `master`, 之后只要



```bash

git push origin master

```





就是把当前分支推送到 "**origin master**" 的意思









**先创建远程库，然后，从远程库克隆**



```bash

$ git clone git@github.com:michaelliao/gitskills.git

```



也可以



```bash

git clone  https://github.com/michaelliao/gitskills.git

```



Git 支持多种协议，默认的`git://`( **速度快 不用每次推送都输入口令** )使用`ssh`，但也可以使用`https` ( **速度慢, 每次推送都必须输入口令** )等其他协议







## 分支管理



Git 鼓励大量使用分支：



```bash

查看分支：git branch



创建分支：git branch <name>



切换分支：git checkout <name>



创建+切换分支：git checkout -b <name>



合并某分支到当前分支：git merge <name>



删除分支：git branch -d <name>

```





![](http://7xj74s.com1.z0.glb.clouddn.com/Markdown_git-2-16-3.png)



我们创建`dev`分支，然后切换到`dev`分支：



```bash

$ git checkout -b dev

```



`git checkout`命令加上`-b`参数表示创建并切换



`git branch`命令查看当前分支：



```bash

$ git branch

* dev

  master



当前分支前面会标一个*号

```



在`dev`分支上工作完成, 可以用`git checkout master`切换回`master`分支



![](http://7xj74s.com1.z0.glb.clouddn.com/Markdown_git-2-16-4.png)



**把`dev`分支的工作成果合并到`master`分支上：**



```bash

$ git merge dev

Updating d17efd8..fec145a

Fast-forward

 readme.txt |    1 +

 1 file changed, 1 insertion(+)



```bash

`Fast-forward`是“快进模式”，也就是直接把`master`指向`dev`的当前提交，所以合并速度非常快。



合并完成后，就可以放心地删除`dev`分支了



```bash

$ git branch -d dev

```





## 解决冲突





![enter image description here](http://7xj74s.com1.z0.glb.clouddn.com/Markdown_git-2-16-5.png)



两个分支有矛盾之处 (有修改) 时, 再 merge会产生冲突



这种情况下，Git 无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突



如在`master`下 **merge** `feature1`



```bash

$ git merge feature1

Auto-merging readme.txt

CONFLICT (content): Merge conflict in readme.txt

Automatic merge failed; fix conflicts and then commit the result.

```



Git用`<<<<<<<，=======，>>>>>>>`标记出不同分支的内容



```bash

Git is a distributed version control system.

Git is free software distributed under the GPL.

Git has a mutable index called stage.

Git tracks changes of files.

<<<<<<< HEAD

Creating a new branch is quick & simple.

=======

Creating a new branch is quick AND simple.

>>>>>>> feature1

```



应该修改后再提交(不用再`add` 了)



![enter image description here](http://7xj74s.com1.z0.glb.clouddn.com/Markdown_git-2-16-6.png)



删除`feature1`分支：



```bash

$ git branch -d feature1

Deleted branch feature1 (was 75a857c).

```



`git log --graph`命令可以看到分支合并图









## Bug 分支 & stash



当你在当前分支开发一个未完成的功能时，却不得已要切换到另外一个分支修复`bug`时，可以用`git stash`保存当前工作状态，**减少不必要的`commit`和`log`记录**







当前`dev`分支正在开发, 不想现在提交, 放下手头的工作切换到`bug`分支`fix bug`, 可

使用`stash`储藏功能, 可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：



```bash

$ git stash

Saved working directory and index state WIP on dev: 6224937 add merge

HEAD is now at 6224937 add merge

```





现在，用`git status`查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug





假定需要在`master`分支上修复，就从`master`创建临时分支：



```bash

$ git checkout -b issue-101

```



记得吗? `-b`是用来创建新分支用的



```bash

$ git commit -m "fix bug 101"

$ git checkout master

# merge 的同时直接提交(commit), 使用 -m 参数

$ git merge --no-ff -m "merged bug fix 101" issue-101

$ git checkout dev

$ git stash pop





$ git stash list  # 查看 stash 列表

$ git stash apply # 应用 stash 内容, 不删除

$ git stash pop   # 弹出 stash 内容, 删除

$ git stash drop  # 删除 stash 内容



# 你可以多次stash，恢复时先用git stash list查看，然后恢复指定的stash，用命令：



$ git stash apply stash@{0}



```



修复后, 切换到`master`分支, 合并, 删除`issue`分支, 回到`dev`分支, 恢复`stash`内容









## feature分支





添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支`master`搞乱了，所以，每添加一个新功能，最好新建一个`feature`分支，在上面开发，完成后，合并`merge`，最后，`删除`该`feature`分支



```bash

$ git checkout -b feature-vulcan

...

$ git checkout dev # 切回dev，准备合并：

# git merge feature-vulcan

# 就在此时，接到上级命令，因经费不足，新功能必须取消！



$ git branch -d feature-vulcan

error: The branch 'feature-vulcan' is not fully merged.



# Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan



# branch的 -D 参数是强行删除, -d 是普通删除

$ git branch -D feature-vulcan





```



##远程协作







查看`远程库`( remote )信息:



```bash

$ git remote

origin



# 显示更详细的信息

# 显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。

git remote -v

origin  git@github.com:michaelliao/learngit.git (fetch)

origin  git@github.com:michaelliao/learngit.git (push)





```





推送分支 `push`



```bash

# master 分支是主分支，因此要时刻与远程同步；

$ git push origin master



# dev 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；

$ git push origin dev



# bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug



# feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。

```





抓取分支 `pull`, `fetch`



`git pull`把最新的提交抓下来



```bash

$ git pull

There is no tracking information for the current branch.

Please specify which branch you want to merge with.

See git-pull(1) for details



    git pull <remote> <branch>



If you wish to set tracking information for this branch you can do so with:



    git branch --set-upstream dev origin/<branch>

```



`git pull`也失败了，原因是没有指定本地`dev`分支与远程`origin/dev`分支的链接，根据提示，设置`dev`和`origin/dev`的链接：



```bash

$ git branch --set-upstream dev origin/dev



# Branch dev set up to track remote branch dev from origin.



$ git pull

Auto-merging hello.py

CONFLICT (content): Merge conflict in hello.py

Automatic merge failed; fix conflicts and then commit the result.

```



---



因此，**多人协作**的工作模式通常是这样：



1. 首先，可以试图用 git push origin branch-name 推送自己的修改



2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并



3. 如果合并有冲突，则解决冲突，并在本地提交



4. 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功



如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令



```bash

git branch --set-upstream branch-name origin/branch-name

```







## git pull 和 git fetch 的区别



`git fetch`：相当于是从远程获取最新版本到本地，不会自动`merge`, 在实际使用中，git fetch更安全一些



```bash

git fetch origin master

git log -p master..origin/master

git merge origin/master

```





 `git pull`：相当于是从远程获取最新版本并`merge`到本地



```bash

git pull origin master

```





## 标签管理



发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本，将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来，所以，标签也是版本库的一个快照



`标签`其实就是指向某个`commit`的指针, `git tag <name>` 就可以为当前分支打上标签



```bash

$ git tag v1.0

$ git tag

v1.0



```



默认标签是打在最新提交的`commit`上的, 如果忘了打标签, 到历史提交的`commit id`，然后打上就可以了：

`git tag <name> <id>`



```bash

$ git log --pretty=oneline --abbrev-commit



$ git tag v0.9 6224937



$ git tag

v0.9

v1.0







```

标签不是按时间顺序列出，而是按字母排序的。可以用`git show <tagname>`查看标签信息：



```bash

$ git show v0.9



commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4

Author: Michael Liao <askxuefeng@gmail.com>

Date:   Thu Aug 22 11:22:08 2013 +0800



    add merge

...08 2013 +0800

```



创建带有说明的标签，用`-a`指定标签名，`-m`指定说明文字：



```bash

$ git tag -a v0.1 -m "version 0.1 released" 3628164

$ git show v0.1

tag v0.1

Tagger: Michael Liao <askxuefeng@gmail.com>

Date:   Mon Aug 26 07:28:11 2013 +0800



version 0.1 released



commit 3628164fb26d48395383f8f31179f24e0882e1e0

Author: Michael Liao <askxuefeng@gmail.com>

Date:   Tue Aug 20 15:11:49 2013 +0800



    append GPL

```







删除标签:

`git tag -d <name>`







创建的`标签`都只存储在`本地`，不会自动推送到远程



如果要推送某个标签到远程，使用命令`git push origin <tagname>`



```bash

$ git push origin v1.0

Total 0 (delta 0), reused 0 (delta 0)

To git@github.com:michaelliao/learngit.git

 * [new tag]         v1.0 -> v1.0

```



一次性推送全部尚未推送到远程的本地标签：`git push origin --tags`

```bash

$ git push origin --tags

Counting objects: 1, done.

Writing objects: 100% (1/1), 554 bytes, done.

Total 1 (delta 0), reused 0 (delta 0)

To git@github.com:michaelliao/learngit.git

 * [new tag]         v0.2 -> v0.2

 * [new tag]         v0.9 -> v0.9

```





要删除远程标签就麻烦一点，先从本地删除：



```bash

$ git tag -d v0.9

```



从远程删除, 删除命令也是`push`



```bash

$ git push origin :refs/tags/v0.9

To git@github.com:michaelliao/learngit.git

 - [deleted]         v0.9

```
