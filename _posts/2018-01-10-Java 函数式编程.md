---
layout: post
title: Java 函数式编程
toc: true
tags: ['Java', '函数式编程']
cover: 'http://7xj74s.com1.z0.glb.clouddn.com/2018-01-24-11-06-42_r68.png'
---
<!-- 

time: 2018-01-10

title: Java 函数式编程

cover: http://7xj74s.com1.z0.glb.clouddn.com/2018-01-24-11-06-42_r68.png

tags: Java, 函数式编程

-->



<!-- more -->



## 1. 函数式编程



在多核 CPU 上，面对大型数据集合，Java 当时欠缺高效的并行操作，为了编写这类处理批量数据的并行类库，Lambda 表达式应运而生。



函数式编程的核心是：在思考问题时候，使用不可变值和函数，函数对每一个值进行处理，映射成另一个值。







## 2. Lambda 表达式



Lambda 表达式通过上下文（要有足够的信息）推测参数类型。





Lambda 表达式内引用的是值，而不是变量，虽然 Java 8 允许引用变量，但也不能去修改它，实际上引用的还是常量。





Lambda 表达式的类型：函数接口（只有一个方法的接口）



Java 中重要的函数接口有：

![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-20-17-13_r21.png)







## 3. Stream 流



**从外部迭代到内部迭代**



for迭代实际上是封装了迭代的语法糖：



```java

int count = 0;

for(Artist artist: allArtists){

    if(artist.isFrom("London")) count++;

}



// for 循环工作原理

int count = 0;

Iterator<Artist> iterator = allArtistss.iterator();

while(iterator.hasNext()){

    Artist artist = iterator.next();

    if(artist.isFrom("London")) count++;

}

```







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-20-23-25_r17.png)





**外部迭代**本质上是一种串行操作



```java

long count = allArtists.stream()

                       .filter(artist ->isFrom("London"))

                       .count() ;

```



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-20-25-54_r61.png)



**内部迭代**：对集合类调用 `stream()` 返回`Stream`接口，这类似于`iterator()`返回`Iterator`对象







像 `filter` 这样只描述 Stream 不产生新的集合，任然返回流（Stream）的方法，叫**惰性求值**方法，而像 `count` 这样从 Stream 产生值的方法叫**及早求值**方法







即使在 filter 的表达式中加入 print 也会不输出任何信息，简单说惰性求值就是就是用到的时候再算，直到遇到像`count`这样的操作拥有一个终止的流，就会被输出



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-21-04-28_r30.png)







**常用的流操作**







### collect



```java

// collect(toList()) 生成新集合(及早求值)

List<String> collected = Stream.of("a", "b", "c").collect(Collectors.toList());



assertEquals(Arrays.asList("a", "b", "c"), collected); // 使用断言看是否一致



```







### map







```java

// map 将一种类型的值转行为另一种类型，转成新的流（惰性求值、常用）

// 传给map的lambda表达式必须是Function接口的实例

List<String> collected = Stream.of("a", "b", "hello")

  							   .map(string -> string.toUpperCase())

  							   .collect(toList());	

```











### filter



```java

// // 传给filter的lambda表达式必须是Predicate接口的实例

List<String> beginningWithNumbers = Stream.of("a", "1abc", "abc1")

  										  .filter(value -> isDigit(value.charAt(0)))

                                          .collect(toList());

```







### flatMap







flatMap 可用 Stream 替换值，然后将多个 Stream 连成一个 Stream







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-22-36-49_r17.png)



map 是用新的值代替 Stream 中的值，flatMap 表达式返回的值限定为 Stream 类型（整个方法返回当然和map一样也是Stream，这里是只lambda表达式也返回的不是任意对象，而是流）







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-21-34-24_r53.png)







### max和min







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-21-46-43_r1.png)







以往进行排序要传一个`Comparator`对象，java8 提供了其静态方法`comparing`，可以方便实现一个比较器，实际上`comparing`方法接受一个函数，返回一个函数







### reduce







`reduce`可以从一组值中生成一个值（例如累加操作）



```java

int count = Stream.of(1,2,3).reduce(0,(acc, element) -> acc+elment)); // acc = acc + element

assertEquals(6, count);



// 等价于

Objcet acc = initValue;

for(Object element: collection){

  acc = combine(acc, element);

}



// reduce 展开操作如下

BinaryOperator<Integer> accumulator = (acc, elemennt) -> acc + element;



int count = accumulator.apply(

	accumulator.apply(

    	accmulator.apply(0,1),

        2,

    ),

    3

)



  

// 定义

reduce <U> U reduce(U identity,

             BiFunction<U,? super T,U> accumulator,

             BinaryOperator<U> combiner) 

  

// 两个参数等价于（不一定是顺序执行的）

U result = identity;

for (T element : this stream)

     result = accumulator.apply(result, element)

return result;   



/* 第三个参数 combiner 的作用



I assume its purpose is to allow parallel computation, 

and so my guess is that it's only used if the reduction 

is performed in parallel. If it's performed sequentially, 

there's no need to use combiner. 



I do not know this for sure -- I'm just guessing based 

on the doc comment "[...] is not constrained to execute 

sequentially" and the many other mentions of "parallel execution"

in the comments.

*/

```







### 方法整合



任务如下：



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-22-14-02_r55.png)







实际上这些操作可以一行就搞定了：



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-22-14-28_r88.png)







### 重构遗留代码











比如：



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-22-18-15_r45.png)



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-22-18-37_r56.png)![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-22-19-29_r49.png)



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-22-20-00_r20.png)



最终：



```java

public Set<String> findTracks(List<Album> albums){

  return albums.stream()

    		   .flatMap(album -> album.getTracks())

               .filter(track -> track.getLength() > 60)

               .map(track -> track.getName())

               .collect(toSet());

}

```







### 多次调用Stream操作







**最好将流操作都链接在一起**，不然可读性、效率都会变差，并且保存了没什么意义的中间结果，并且难以自动并行化处理



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-15-22-45-13_r28.png)







### 高阶函数







高阶函数是接受另一个函数作为参数，或者返回一个函数的函数







如果函数参数列表包含函数接口，或者返回一个函数接口，这个函数就是**高阶函数**。







比如map接受一个Function接口的lambda表达式，就是一个高阶函数，其实 Stream 接口的几乎所有函数都是高阶函数









## 4. 类库



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-17-01-54_r56.png)







可在 debug 中传入一个 lambda 表达式







```java

logger.debug(() -> "Look at this: " + expensiveOperation());





// 这个方法实际上是这样声明的

// Supplier 函数接口（只有get()方法）

public void debug(Supplier<String> message){

  if(isDebugEnabled()) debug(message.get());

}



```







### 基本类型



尽可能使用对基本类型做过特殊处理的方法，进而改善性能







为减少性能开销（如int和Integer）Stream 类的方法对某些**基本类型**和其对应**类类型**做了区分，Java8 中仅对整形、长整型和双浮点型做了特殊处理,：



如果方法**返回类型为基本类型**,则在基本类型前加 **To**



如  **ToLongFunction**







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-17-11-00_r77.png)







如果**参数是基本类型**, 则不加前缀只需类型名,







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-17-11-49_r62.png)



如 **LongFunction**







如果**高阶函数使用基本类型**,则在操作后加后缀 **To** 再加基本类型,如 **mapToLong**。







这些基本类型都有与之对应的 Stream, 以基本类型名为前缀,如 LongStream。







事实上,mapToLong 方法返回的不是一个一般的 Stream,而是一个特殊处理的 Stream。在这个特殊 的 Stream 中,map 方法的实现方式也不同, 它接受一个 LongUnaryOperator 函数, 将一个长整型值映射成另一个长整型值。



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-17-15-31_r31.png)



通过一些高阶函数装箱方法,如 **mapToObj** ,也可以从一个基本类型的 Stream 得到一个装箱后的 Stream,如 `Stream<Long>`。



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-17-07-49_r51.png)



上面`mapToInt`返回一个特殊的`IntStream`







### 重载解析







javac 对方法重载是选择最具体的类型







Lambda 表达式的类型就是对应的函数接口类型







总而言之,Lambda 表达式作为参数时, 其类型由它的目标类型推导得出, 推导过程遵循如下规则:



- 如果只有一个可能的目标类型,由相应函数接口里的参数类型推导得出;

- 如果有多个可能的目标类型,由最具体的类型推导得出;

- 如果有多个可能的目标类型且最具体的类型不明确,则需人为指定类型。







### @FunctionalInterface（函数式接口）



事实上，每个用作函数接口的接口都应该添加这个注释，因为只有一个方法的接口，并不都是为了使用lambda表达式







该注释会强制 javac 检查一个接口是否符合函数接口的标准。如果该注释添加给一个枚举

类型、类或另一个注释,或者接口包含不止一个抽象方法,javac 就会报错。重构代码时,

使用它能很容易发现问题。







### 默认方法







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-18-16-28_r99.png)







注意默认方法前面添加了`default`，并且在继承规则上也普通方法也有区别



和类不同,接口没有成员变量,因此默认方法只能通过调用子类的方法来修改子类本身,避免了对子类的实现做出各种假设。







接口虽说不能有具体方法的实现，但是有`default`关键字后，是可以有代码块的







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-18-24-37_r28.png)



`ParentImpl`没有实现 `welcome` 方法，因此自然继承了该**默认方法**c



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-18-24-50_r51.png)



一个新的`Child`接口继承`Parent`接口，并且实现了自己的默认`welcome方法`，`ChildImpl`实现类不会实现 welcome 方法，因此也继承了接口的默认方法。



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-18-26-33_r48.png``)







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-16-18-35-18_r78.png)



## 5. 高級集合类和收集器



### 方法引用



方法引用可代替 Lambda 表达式(只是语法的简化)



只要选对了函数接口，可以自动支持多个参数



```java

artist -> artist.getName();



// 方法引用（虽然是一个方法，但不需要加括号，因为并不调用）

// 语法为 Classname::methodName

// 与 lambda 表达式等价

Artist::agetName

```



对于返回构造函数的 Lambda 表达式，可以这样写



```java

(name, nationality) -> new Artist(name, nationality);



// 直接ClassName::new

Artist::new

```



还可以创建数组：



```java

String[]::new

```





### 元素顺序



加入流操作后，直观上元素按顺序处理，称为**出现顺序**。`出现顺序`的定义依赖于数据源和对流的操作。



如果集合本身有序，流的元素就按出现顺序排列。

如果集合本身无序，流也无需。

有些集合本事无序，但中间操作比如`sorted()`会产生有序。



### Collector 收集器





`collect()`的参数是`Collector`收集器,如`toList()`等返回的都是Collector



```text

Interface Collector<T,A,R>



Type Parameters:

T - the type of input elements to the reduction operation

A - the mutable accumulation type of the reduction operation (often hidden as an implementation detail)

R - the result type of the reduction operation

```



`collect(toList())`可以从流中生成列表，除此之外可以定制一个类将想要的数据结构抽象出来。



收集器就是一种通用的、从流中生成复杂值的结构。



收集器在`java.util.stream.Collectors`中



 `toList()`和`toSet()`都不需要指定类型参数





 `toCollection`的话，要接受一个函数(构造器)作为参数，比如`TreeSet::new`



```java

stream.collect(toCollection(TreeSet::new));

```



### 转行成值



collect 方法中传入`minBy()`和`maxBy()`函数可以生成值，比如







注：



`maxBy()`接收的是一个比较器



`Function<T,R>`接口是传入T，返回R的函数接口



`comparing`接受一个函数接口如`Function`/Lambda表达式，返回的是一个`Comparator<T> `



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-17-34-57_r87.png)



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-18-52-52_r11.png)



### 数据分块



`partitioningBy`和`collect`一样也是一个接收器，传入一个`Predicate`对象，返回的是一个`Map<Boolean, T>`集合



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-18-54-19_r56.png)



### 数据分组



`groupingBy`接收器，接收的是返回要分组任意值 G 的函数接口，返回`Map<G, T>`集合







```java

public static <T,K> Collector <T,?,Map<K,List<T>>> 

                    groupingBy(Function<? super T,? extends K> classifier, 

                               downStreamCollector)

```



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-18-55-08_r48.png)





### 字符串



`Collectors.joining`可以连接字符串





![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-18-58-22_r4.png)



可以写成：



```java

String result = artists.stream()

                       .map(Artist::getName)

                       .collect(Collectors.joining(", ",","[","]"))

                

```



### 组合Collector



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-19-16-41_r24.png)



`groupingBy`第二个参数可以是个`downStream`的`Collector`，表示使用下游的另一个收集器对每组元素再操收集，最好将结果映射为一个Map



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-19-18-18_r71.png)



这里就是先分组，再对分组后每组元素进行计数，本来应该是`Map<Artist, List<Album>>`，现在就变成了`Map<Artist, Long>`



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-19-24-34_r30.png)



`mapping`也一样，第二个参数是下游收集器（toList），功能和`map`类似





![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-19-24-58_r26.png)





### 重构和定制Collector



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-20-00-28_r45.png)



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-20-00-38_r43.png)







>  [reduce](../../../java/util/stream/Stream.html#reduce-U-java.util.function.BiFunction-java.util.function.BinaryOperator-)(U identity,[BiFunction](../../../java/util/function/BiFunction.html)<U,? super [T](../../../java/util/stream/Stream.html),U> accumulator,[BinaryOperator](../../../java/util/function/BinaryOperator.html)<U> combiner)



这里reduce有3个参数，第一个`identity`，第二个`accumulator`，第三个是`combiner`，Performs a [reduction](package-summary.html#Reduction) on the elements of this stream, using the provided identity, accumulation and combining functions.











![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-20-00-49_r90.png)



这里reduce第三个参数的lambda表达式，接受两个`StringBuilder`对象，连接起来。







如何理解？



> 初始化一个StringBuilder，accumulator 接受一个StringBuilder和一个字符串，返回StringBuilder，第三个combiner对于平行计算（非顺序的）是有必要的





![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-20-18-41_r36.png)



```java

// add 方法返回连接新元素后的结果

public StringCombiner add(String element){

    if(areAtStart()){

        builder.append(prefix);

    }

    else{

        builder.append(delim);

    }

    builder.append(element);

    return this;

}

```



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-20-20-18_r67.png)



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-20-21-09_r68.png)











将上面的reduce操作重构成一个收集器 Collector，下面是使用方法



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-20-21-22_r57.png)







一个收集器由4部分组成：supplier, accumulator, combine, finisher







```java

public class StringCollector implements Collector<String, StringCombiner, String>{

  // supplier 是创建容器的工厂, 这里就是创建StringCombiner

  // 和reduce的第一个操作类似，它是后续操作的初始值

  // 搜集操作一开始，Supplier先创建新的容器

  public Supplier<StringCombiner> supplier(){

    return ()->new StringCombiner(delim, prefix, suffix);

  } 

  

  // accumulator 和 reduce 第二个参数一样，结合之前的结果和当前值，生成并返回新的值

  public BiConsumer<StringCombiner, String> accumulator(){

    return StringCombiner::add;

  }

  

  // 类似第三方法，如果有两个容器，需要将其合并

  public BinaryOperator<StringCombiner> combiner(){

    return StringCombiner::merge;

  }

  

  // 最终转成字符串

  public Function<StringCombiner, String> finisher(){

    return StringCombiner::toString;

  }

}

```







**supplier**







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-21-44-08_r76.png)







**accumulator**







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-21-44-29_r61.png)



**combiner**



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-21-43-47_r50.png)



**finisher**



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-21-46-20_r28.png)











StringCombiner 不要自己编写，有一个`java.util.StringJoiner`类，有类似的API







关于收集器，还有一点就是**特征（characeristics方法）**











上述练习不仅在于展示定制收集器的工作原理，还有有助于自己编写收集器，特比是对特定的类，标准集合类中没有提供收集操作，就要自己写收集器类







收集值的容器和想要创建的值不一定一样，这时候要用finisher方法转换一下







### 对收集器的归一化处理







就像之前看到的那样,定制收集器其实不难,但如果你想为自己领域内的类定制一个收集器,不妨考虑一下其他替代方案。







最容易想到的方案是构建若干个集合对象,作为参数传给领域内类的构造函数。如果领域内的类包含多种集合,这种方式又简单又适用。







当然,如果领域内的类没有这些集合,需要在已有数据上计算,那这种方法就不合适了。但即使如此,也不见得需要定制一个收集器。你还可以使用 `reducing` 收集器,它为流上的归一操作提供了统一实现。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-21-54-32_r72.png)











### 一些细节







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-21-56-15_r47.png)







**Map 的 forEach 方法很好用 !**



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-17-21-57-21_r1.png)







## 6.数据并行化







为什么要并行化？并行化什么时候会带来性能提升？







并行和并发的区别







并行要利用多核处理器







如 果 已 经 有 一 个 Stream 对 象, 调 用 它 的`parallel` 方法就能让其拥有并行操作的能力。







如果想从一个集合类创建一个流,调用 `parallelStream` 就能立即获得一个拥有并行能力的流。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-10-59-58_r88.png)







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-11-00-57_r81.png)







### 模拟系统



我们这里要讨论的是**蒙特卡洛模拟法**。蒙特卡洛模拟法会重复相同的模拟很多次,每次模拟都使用随机生成的种子。每次模拟的结果都被记录下来,汇总得到一个对系统的全面模拟。蒙特卡洛模拟法被大量用在工程、金融和科学计算领域。



> N 代表模拟次数，IntStream.range(0, N) 创建大小为N的流

>

> 对Stream对象调用parallel方法使用流进行并行化操作

>

> toDiceThrows 函数模拟连续两次掷骰子事件，返回两次点数和

>

> groupingBy(Function, Collector) 接受一个分类函数接口（接受side返回side），其下游函数接口summingDouble(Function)对每组元素计算概率 （元素个数个1/N 累加，有点巧妙）



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-11-09-39_r38.png)







这是一个很好的并行化案例，能带来性能高提升







如果手动实现蒙特卡洛并行算法，要写很多代码在处理调度和等待线程池中某项任务完成。







```java

package pers.concurrent;



import java.util.ArrayList;

import java.util.List;

import java.util.Map;

import java.util.concurrent.*;



public class ManualDIceRolls {



    private static final int N = 100000000;

    private final double fraction;

    private final Map<Integer, Double> results;

    private final int numberOfThreads;

    private final ExecutorService executor; // 线程池

    private final int workPerThread;



    public static void main(String[] args) {

        ManualDIceRolls roles = new ManualDIceRolls();

        roles.simulateDiceRoles();

    }



    public ManualDIceRolls() {

        fraction = 1.0 / N;

        results = new ConcurrentHashMap<>();

        numberOfThreads = Runtime.getRuntime().availableProcessors();

        executor = Executors.newFixedThreadPool(numberOfThreads);

        workPerThread = N / numberOfThreads; // 每个工作几个线程

    }



    public void simulateDiceRoles() {

        List<Future<?>> futures = submitJobs();

        awaitCompletion(futures);

        printReuslts();

    }



    private void printReuslts() {

        results.entrySet()

                .forEach(System.out::println);

    }



    private List<Future<?>> submitJobs() {

        List<Future<?>> futures = new ArrayList<>();

        for (int i = 0; i < numberOfThreads; i++) {

            futures.add(executor.submit((makeJob())));

        }

        return futures;



    }



    private Runnable makeJob() {

        return () -> {

            ThreadLocalRandom random = ThreadLocalRandom.current();

            for (int i = 0; i < workPerThread; i++) {

                int entry = twoDiceThrows(random);

                accumulateResult(entry);

            }

        };

    }



    private void accumulateResult(int entry) {

        results.compute(entry, (key, previous) ->

            previous == null ? fraction : previous + fraction

        );

    }



    private int twoDiceThrows(ThreadLocalRandom random) {

        int firstThow = random.nextInt(1, 7);

        int secondThrow = random.nextInt(1, 7);

        return firstThow + secondThrow;

    }



    private void awaitCompletion(List<Future<?>> futures) {

        futures.forEach(future -> {

            try{

                future.get();

            }

            catch (InterruptedException | ExecutionException e){

                e.printStackTrace();

            }

            executor.shutdown();

        });

    }

}

```







### 限制







之前调用 reduce 方法,初始值可以为任意值, 为了让其在并行化时能工作正常, 初值必须为组合函数的**恒等值**。拿恒等值和其他值做 reduce 操作时,其他值保持不变。







比如,使用 reduce 操作求和, 组合函数为 `(acc, element) -> acc + element`, 则其初值必须为 0, 因为任何数字加 0, 值不变。







reduce 操作的另一个限制是**组合操作必须符合结合律**。这意味着只要序列的值不变,组合操作的顺序不重要。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-13-34-30_r92.png)







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-13-34-43_r78.png)



### 性能







影响并行流性能的主要因素有 5 个,依次分析如下。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-13-35-41_r30.png)











使用并行流框架,理解如何分解和合并问题是有帮助的, 这样能指定底层如何工作, 不必了解框架细节.



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-13-37-02_r2.png)



在底层,并行流还是沿用了 `fork/join` 框架。`fork` **递归式地分解问题**, 然后每段并行执行, 最终由 `join` 合并结果, 返回最后的值。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-13-37-59_r36.png)



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-13-38-52_r14.png)







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-14-25-24_r51.png)







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-14-27-49_r51.png)







### 并行化数组操作







Java 8 还引入了一些针对数组的并行操作, 脱离流框架也可以使用 Lambda 表达式。







这些操作都在工具类`Arrays`中







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-14-38-58_r97.png)



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-14-39-06_r53.png)



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-14-39-43_r80.png)



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-14-41-50_r34.png)![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-18-14-40-36_r83.png)











## 7. 测试、调试和重构







本章主要探讨**如何在代码中使用 Lambda 表达式的技术,也会说明什么情况下不应该**







先看几个例子,看看如何将现有代码重构为使用 Lambda 表达式的代码







使用 Lambda 表达式重构代码有个时髦的称呼:Lambda 化







### 应该考虑用 Lambda 的情况



#### 进进出出 、 摇摇晃晃



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-19-22-42-31_r40.png)







这段代码先调用`isDebugEnabled` 方法抽取布尔值,用来检查是否启用调试级别,如果启用,则调用 Logger对象的相应方法记录日志。如果你发现自己的代码不断地查询和操作某对象,目的只为了在最后给该对象设个值,那么这段代码就本该属于你所操作的对象。







**与其查询并设置一个对象的值,不如传入一个 Lambda 表达式**，该表达式按照**计算得出的值**执行相应的行为。当程序处于调试级别, 并且**检查是否使用 Lambda 表达式的逻辑被封装在 Logger 对象中**时,才会调用 Lambda 表达式。



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-19-22-49-46_r48.png)







上述记录日志的例子也展示了**如何使用 Lambda 表达式**更好地面向对象编程(OOP),面向对象编程的核心之一是**封装局部状态**,比如日志的级别。通常这点做得不是很好,isDebugEnabled 方法暴露了内部状态。如果使用 Lambda 表达式,外面的代码根本不需要检查日志级别。







#### 孤独的覆盖



这个代码是使用继承,其目的只是为了覆盖一个方法。



ThreadLocal 能创建一个工厂,为每个线程最多只产生一个值。



这是确保非线程安全的类在并发环境下安全使用的一种简单方式。假设要在数据库中查询一个艺术家,但希望每个线程只做一次这种查询







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-19-22-53-22_r38.png)







在 Java 8 中,可以为工厂方法 `withInitial()` 传入一个 Supplier 对象的实例来创建对象



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-19-22-54-00_r100.png)







#### 同样的东西写两遍







什么时候该将 WET 的代码 Lambda 化?这里有一个信号可以参考**。如果有一个整体上大概相似的模式,只是行为上有所不同,就可以试着加入一个 Lambda 表达式。**







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-18-33_r76.png)







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-19-01_r77.png)







然而这段代码仍然有重用可读性的问题,因为有一些抽象和共性只能使用领域内的知识来

表达， 流无法提供。



想一下如何实现这样一个函数。我们返回一个 long,统计所有专辑的某些特征,还需要一个 Lambda 表达式,告诉我们统计专辑上的什么信息。也就是说我们的方法需要一个参数,该参数为每张专辑返回一个 long,方便的是,Java 8 核心类库中已经有了这样一个类型 ToLongFunction。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-20-25_r2.png)











###  Lambda表达式的单元测试







Lambda 表达式给单元测试带来了一些麻烦,Lambda 表达式没有名字,无法直接在测试代码中调用。







解决该问题有两种方式。第一种是将 Lambda 表达式放入一个方法测试, 这种方式要测那个方法, 而不是 Lambda 表达式本身。



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-23-54_r11.png)







在这段代码中, Lambda 表达式唯一的作用就是调用一个 Java 方法。将该 Lambda 表达式单独测试是不值得的,它的行为太简单了。



如果换我来测试这段代码,我会将重点放在方法的行为上。比如例 7-9 测试了流中有多个单词的情况,它们都被转换成对应的大写。



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-25-13_r32.png)











有时候 Lambda 表达式实现了复杂的功能,它可能包含多个边界情况、使用了多个属性来计算一个非常重要的值。你非常想测试该段代码的行为,但它是一个 Lambda 表达式,无法引用。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-26-46_r65.png)



如果要测试这段代码,我们必须创建一个列表,然后将想要测试的各种情况都测试到。例7-11 展示了这种方式有多么繁琐,别担心,我们有办法!







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-27-56_r48.png)











别用 Lambda 表达式。我知道,在一本介绍如何使用 Lambda 表达式的书里,这个建议有点奇怪,但是方楔子钉不进圆孔。既然如此,大家一定会问如何测试代码,同时享有Lambda 表达式带来的便利?







**请用方法引用：任何 Lambda 表达式都能被改写为普通方法,然后使用方法引用直接引用。**



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-29-32_r41.png)







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-29-47_r11.png)











### 在测试替身时使用 Lambda 表达式



编写单元测试的常用方式之一是使用测试替身描述系统中其他模块的期望行为。



测试替身让你能用单元测试来实现这种隔离。







测试替身也常被称为模拟 ,事实上测试存根和模拟都属于测试替身。区别是模拟可以验证代码的行为。







测试代码时, 使用 Lambda 表达式的最简单方式是实现轻量级的测试存根。如果**交互的类本身就是一个函数接口,**实现这样的存根就非常简单和自然。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-32-33_r15.png)







多数的测试替身都很复杂,使用 **Mockito** 这样的框架有助于更容易地产生测试替身。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-16-35-04_r58.png)







Mockito 使用 Answer 接口允许用户提供其他行为,换句话说,这是我们的老朋友:代码即数据。之所以在这里能使用 Lambda 表达式,是因为 Answer 本身就是一个函数接口。







（出现需要了再研究）



### 惰性求值和调试







调试时通常会设置断点,单步跟踪程序的每一步。**使用流时,调试可能会变得更加复杂,因为迭代已交由类库控制,而且很多流操作是惰性求值的**。







在传统的命令式编程看来,代码就是达到某种目的的一系列行动,在行动前后查看程序状态是有意义的。在 Java 8 中,你仍然可以使用 IDE 提供的各种调试工具,但有时需要调整实现方式,以期达到更好的结果。







（出现需要了再研究）







### 日志和打印消息 peek







假设你要在集合上进行大量操作,你要调试代码,你希望看到每一步操作的结果是什么。

**可以在每一步打印出集合中的值,这在流中很难做到,因为一些中间步骤是惰性求值的。**











该程序找出了专辑上每位艺术家来自哪个国家



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-17-39-32_r48.png)



现在可以使用 forEach 方法打印出流中的值,这同时会触发求值过程。但是这样的操作有个缺点:我们无法再继续操作流了,流只能使用一次。如果我们还想继续,必须重新创建流。



这样的代码会有多难看:



![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-17-40-47_r63.png)



**流有一个方法让你能查看每个值,同时能继续操作流，这就是 peek 方法**，其会在操作流之后返回原来的流（流本身没变化，相当于一个中间过程），不用再重现创建一个流。







![](http://7xj74s.com1.z0.glb.clouddn.com/2018-01-20-17-42-26_r28.png)











**在流中间设置断点**：记录日志这是 peek 方法的用途之一。为了像调试循环那样一步一步跟踪,可在 peek 方法中加入断点,这样就能逐个调试流中的元素了。











此时, **peek 方法可知包含一个空的方法体,只要能设置断点就行。**有一些调试器不允许在空的方法体中设置断点,此时,我将值简单地映射为其本身,这样就有地方设置断点了,虽然这样做不够完美,但只要能工作就行。
























